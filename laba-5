"""
Задана рекуррентная функция. Область определения функции – натуральные числа.
 Написать программу сравнительного вычисления данной функции рекурсивно и итерационно.
  Определить границы применимости рекурсивного и итерационного подхода.
   Результаты сравнительного исследования времени вычисления представить в табличной и графической форме в виде отчета по лабораторной работе.
15.	F(1) = 1; G(1) = 1; F(n) = (-1)n*(F(n–1) – G(n–1))/(n+5)!, G(n) = F(n–1) + sin(n), при n >=2"""


import math
import time
import matplotlib.pyplot as plt
import functools
"""n это переменная для значения n"""
n=-1
"""one это переменная для определения знака"""
one=1
one_sin=1
"""степень в ряде тейлора"""

"""k это переменная для выбора режима работы"""
k=-1
timer=[]
timer_rec=[]
"""ans это переменная для ответа пользователя """
ans=1
"""шаг графика"""
step=-1
"""точность синуса"""
eps=0.000001
"""результат синуса"""
res_sin=0
"""рекурсия"""
@functools.lru_cache(maxsize=100000)
def factrial(x):
    if x == 1:
        return x
    else:
        return x * factrial(x - 1)

def rec_f(x,one,res_sin):

    if x < 2:
        return 1
    else:
        one*=-1

        return  (one)*(rec_f(x - 1,one,res_sin)-rec_g(x-1,one,res_sin))/factrial(x+5)


"""итерация"""

def it_f(x):
    cata_f=[1]*3
    cata_g=[1]*3
    one = 1
    for i in range(2,x+1):
        one *= -1
        cata_g[-1]=cata_f[0]+(it_sin(cata_f[-1]))
        cata_f[-1]=(one * (cata_f[0] - cata_g[0]) /  it_fact(x + 5))
        cata_f[0],cata_f[1]=cata_f[1],cata_f[2]
        cata_g[0], cata_g[1] = cata_g[1], cata_g[2]

    return cata_f[-1]

@functools.lru_cache(maxsize=100000)
def it_fact(x):
    factorial=x
    for i in range(1, x):
        factorial = factorial * i

    return factorial

def it_sin(x):
    res_help = x
    """ сумма ряда на старте равна нулю"""
    res_sin = 0
    """ порядковый номер слагаемого в ряду Тейлора"""
    i = 1

    while max(-res_help,res_help) > eps:
        """ добавляем слагаемое к общей сумме"""
        res_sin = res_sin + res_help
        """вычисляем следующее слагаемое"""
        res_help = res_help * (-1) * (x * x) / ((2 * i + 1) * (2 * i))
        """увеличиваем порядковый номер слагаемого в ряду Тейлора """
        i = i + 1

        """ возвращаем сумму как результат работы функции """
    return res_sin
"""рекурсия"""
@functools.lru_cache(maxsize=100000)
def sinFunc(res_sin,x,res_help,i):
    if max(-res_help,res_help) < eps:
        return res_sin
    else:
        res_sin=res_sin+res_help
        res_help=res_help * (-1) * (x*x) / ((2*i+1) * (2*i))

        return sinFunc(res_sin,x,res_help,i+1)


def rec_g(x, one, res_sin):
    if x < 2:
        return 1
    else:
        return (rec_f(x - 1,one,res_sin) + (sinFunc(res_sin,x,res_help=x,i=1)))

"""ввод числа n"""
while n < 1:
    print("Введите натуральное число от 1 ")
    n = int(input())
while step<1:
    step=int(input("Введите шаг графика от 1"))
graf = list(range(1, n + 1,step))
graf[0]=n


"""выбор режима работы программы 0-рекурсия 1-итерация 2-оба"""
while k != 0 and k != 1 and k != 2:
    print("Выберите режим работы 0-рекурсия 1-итерация 2-оба")
    k = int(input())

if (n >=  33 and (k == 0 or k == 2)) or (n >= 5000 and (k == 1 or k == 2)):
    print("работа программы может занять большое время ,вы хотите продолжить? \n 1=да 0=нет")
    ans = int(input())

    while ans != 1 and ans != 0:
        print("работа программы может занять большое время ,вы хотите продолжить? \n 1=да 0=нет")
        ans = int(input())


if k == 0 and ans == 1:
    k= 0
    for i in graf:
        start = time.time()
        res = rec_f(n,one,res_sin)
        end = time.time()
        timer.append(end-start)
        rec_times = end - start
        k += 1
        print(k,"№Результат рекурсии ",res,"\nВремя выполнения",rec_times,"\n\n")
    """графики"""
    plt.plot(graf, timer, label='рекурсионная функция.')
    plt.legend(loc=2)
    plt.xlabel('Значение n')
    plt.ylabel('Время выполнения (c)')
    plt.show()

if k == 1 and ans == 1:
    k=0
    for i in graf:
        start = time.time()
        result = it_f(i)
        end = time.time()
        timer.append(end - start)
        iter_times = end - start
        k += 1
        print(k,"№Результат рекурсии ",result,"\nВремя выполнения",end-start,"\n\n")
    """графики"""
    plt.plot(graf, timer, label='Итерационная функция.')
    plt.legend(loc=2)
    plt.xlabel('Значение n')
    plt.ylabel('Время выполнения (c)')
    plt.show()
if k == 2 and ans == 1:
    k=0
    for i in graf:
        start = time.time()
        result = it_f(i)
        end = time.time()
        timer.append(end-start)
        start_rec = time.time()
        res = rec_f(n,one,res_sin)
        end_rec = time.time()
        timer_rec.append(end_rec-start_rec)
        rec_times = end_rec-start_rec
        iter_times = end-start
        k +=1
        print("\n",k,"№результат рекурсии ", res,"---------результат итерации",result,"-----------время  РЕКУРСИИ ",end_rec-start_rec,"-------время  ИТЕРАЦИИ",end-start)
    """графики"""
    plt.plot(graf, timer, label='Итерационная функция.')
    plt.plot(graf, timer_rec, label='Рекусионная функция.')
    plt.legend(loc=2)
    plt.xlabel('Значение n')
    plt.ylabel('Время выполнения (c)')
    plt.show()
